
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Introduction &mdash; Wonderland Engine 0.9.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/flasky.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Wonderland Engine 0.9.0 documentation" href="../index.html" />
    <link rel="next" title="Doorknob" href="../doorknob/index.html" />
    <link rel="prev" title="Wonderland Engine 0.9 Documentation" href="../index.html" />
   
  
  <link media="only screen and (max-device-width: 480px)" href="../_static/small_flask.css" type= "text/css" rel="stylesheet" />

  </head>
  <body>
  
  

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../http-routingtable.html" title="HTTP Routing Table"
             >routing table</a> |</li>
        <li class="right" >
          <a href="../doorknob/index.html" title="Doorknob"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../index.html" title="Wonderland Engine 0.9 Documentation"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Wonderland Engine 0.9.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<div class="section" id="purpose">
<h2>Purpose<a class="headerlink" href="#purpose" title="Permalink to this headline">¶</a></h2>
<p>Through this page, I hope to guide you, the reader, through all the stages of
the design and development of the Wonderland Engine. By doing this, I hope to
help you better understand the engine at a higher level, as well as some the
background behind the engine. Hopefully, you will find this useful in
determining whether the Wonderland Engine is right for your group or not, and
that it will serve future developers and administrators in understanding some
basic concepts behind the engine.</p>
<p>If you find any of the design descriptions confusing, I have included some UML
diagrams at the bottom of the page. My hope is that these diagrams will help
bring a greater understanding to the design itself.</p>
</div>
<div class="section" id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>Before any code was actually written, and before I had any idea that I would be
writing a scoring engine, I had started participating in the first teams that
my university, the University of Washington Bothell Campus, had sent to the
Pacific Rim Collegiate Cyber Defense Competition. While competing during the
2012 Competition, my team had done a pretty reasonable move and blocked any
incoming requests from outside our network from reaching the database, domain,
and intranet systems. For most systems, this is a very reasonable layout, but
unfortunately the database wasn&#8217;t written to accommodate this.</p>
<p>The database that was in use up until that competition was hard coded to use
the public IPs of each system it was checking the uptime on. All these systems
were ones that it was not showing uptime for, even though technically, they
were up. As I learned later while designing this scoring engine, the paths were
hard coded, and in fact it took a significant amount of effort on the
competition organizer&#8217;s part to set it up for new competitions such as the
smaller ones that my team started to participate in during the summer and fall
of 2012.</p>
<p>This wasn&#8217;t the only problem, however. The database didn&#8217;t have any concept of
&#8216;timed&#8217; checks (what I call inject checks). This meant that judges had to
receive paper instructions on how to run scripts installed on each competition
machine and interpret the output themselves. It also didn&#8217;t have any concept of
checks which could subtract points for attackers successfully being able to
break in to the systems that teams are supposed to protect. It didn&#8217;t even
support IPv6, which will become very important in the next few years.</p>
<p>This is why I decided that, for my Cooperative Education project that was
required for me to graduate from University of Washington Bothell&#8217;s CSSE
program, I would create a new engine to replace the old one. I worked closely
with the people who set up the PRCCDC event every year as well as the
aforementioned smaller competitions to design it how they needed it. Throughout
the lifecycle of this project, I have learned many new skills in both python
and project management that I hope to use in future jobs. I hope to continue
working on this in the future.</p>
</div>
<div class="section" id="engine-design">
<h2>Engine Design<a class="headerlink" href="#engine-design" title="Permalink to this headline">¶</a></h2>
<p>The Wonderland Engine was created with modularity as the most crucial element
of its design. Before even starting on any code, I took a month to create a
50-page design document which described its architecture and each path that the
would have, including what was the input for that path and its output. This has
been incorporated into this documentation, although some elements of the
original design were changed along the span of developing the project.</p>
<p>One of the first design decisions I made was that the engine would utilize the
web using a REST-based architecture. My reasoning for this was that it would
need to be accessed across a large variety of systems, including Linux,
Windows, and eventually even Mac. It would be a pain for the system
administrator to have to set up a client on each workstation in order to allow
teams access to the scoring engine, so the next best setup was using a web
browser.</p>
<p>Another was that this would be utilizing a multilayer master-worker model in
order to run the checks that score the competition. This would be done from the
server itself, and wouldn&#8217;t require any software to be installed on the client.
The only requirement would be that the server running the scoring engine would
have both a public IP on the competition environment, as well as a private IP
for each team&#8217;s network. By utilizing this private IP, the engine would be able
to access the various team machines while allowing teams to maintain good
security practices.</p>
<p>Very early on, the scoring server was separated out into two different modules.
These were the scoring daemon (aka White Rabbit) and the REST server (aka
Cheshire Cat that gave access to the data that the scoring server generated.
Unfortunately, python servers are started with several processes, which forced
me to consider options for communication outside of traditional pipes. I
considered using sockets, but decided that wouldn&#8217;t allow for the flexibility
that I needed. Eventually, I ended up using Redis&#8217;s pub sub feature. By
utilizing this, the REST interface did not care about what daemon, if any, it
communicated with, and the daemon didn&#8217;t care about what clients it was getting
its commands from. This allows for a more modular approach to detecting changes
across databases.</p>
<p>From these design decisions emerged the the three base components included with
the engine, Cheshire Cat, White Rabbit, and Doorknob. White Rabbit, as with the
character from the books, is mostly concerned with making sure that all the
checks run in a timely manner. Cheshire Cat just lazily takes the REST calls
and converts them into data to be submitted to or returned from the database,
and will occasionally notify White Rabbit that data it is concerned about in
the database has changed through Redis. Doorknob is the wrapper around the
database, which is where all the data for the scoring engine lives, and so,
again like the character from the book, can be considered the portal to
Wonderland itself. Details on each are available below.</p>
</div>
<div class="section" id="doorknob">
<h2>Doorknob<a class="headerlink" href="#doorknob" title="Permalink to this headline">¶</a></h2>
<p>Doorknob was one of the first pieces of code to actually be created because, at
the time, I did not know whether I&#8217;d be using a SQL-based architecture such as
MySQL or PostgreSQL, or a NoSQL-based one with MongoDB. In addition, I knew
that not everyone would like to have to install MongoDB just for this engine,
so I decided that the database should be able to be swapped out for another if
so desired. Due to these desires, Doorknob came into existence.</p>
<p>One design approach I considered that would have worked great for MongoDB was
that I use an ORM model and encapsulate each type of object into a class
utilizing metaclasses for transforming them into database-level objects. Quite
a few good frameworks exist already for MongoDB, MySQL, and PostgreSQL, but
none allow for either of those to be used. In addition to the fact that ORMs
can be rather tricky when it comes to handling data that requires more than
one table in traditional SQL databases (thinking of things like key-value
stores or arrays), one that supported both SQL and NoSQL would only be able to
reliably support a few common object types such as ints and strings. This would
have spun out of control quickly, and would have made it harder for developers
to create new wrappers for their preferred database.</p>
<p>Instead, I decided to create an abstract class that contained an abstract
method for each action either White Rabbit or Cheshire Cat would need. These
would have the arguments that they needed and be able to interpret them
accordingly depending on the database in use. If you wanted to support a
different database, all you&#8217;d have to do is inherit from the DBWrapper class
and implement all the abstract methods that it creates. With this technique,
what the DBWrapper does and doesn&#8217;t support can be adequately specified and
it would require minimal conceptual confusion from the developer.</p>
<p>However, this approach does have its downsides too. In terms of amount of code,
this approach generates a lot more, with DBWrapper containing 88 methods at the
time of this writing. However, many of those do similar things but with
different sets of data (such as users vs machines). This may have been able to
be handled in a more object-oriented way, with different classes that inherit
from a common class, for example, but allowing that common class to be dynamic
and deciding how it would be abstract enough to work across different databases
would have presented similar problems to an ORM-style model. Due to these
conceptual downsides, I took the KISS (Keep It Super Simple) approach and
used one method per action per set of data.</p>
</div>
<div class="section" id="cheshire-cat">
<h2>Cheshire Cat<a class="headerlink" href="#cheshire-cat" title="Permalink to this headline">¶</a></h2>
<p>Cheshire Cat was created as an easy way to access the data across the many
machines that would inevitably be deployed for Cyber Defense Competitions. By
using a REST interface for the data, no special software would have to be
deployed to any machines in order to communicate with the scoring engine. A web
frontend could be created to make AJAX calls to the scoring engine, which would
then work in any standard web browser or via the command line when using tools
like curl. Plus, by using a REST interface, the scoring engine can be located
on a separate machine from the actual scoring process, allowing for more
control over the scoring engine&#8217;s environment.</p>
<p>The design of Cheshire Cat is fairly simple. It submits and queries data
through Doorknob to the administrator&#8217;s database of choice. That data is then
returned to the user in JSON, with dates being represented by a Unix timestamp.
It does provide a basic authentication system and authorization system in order
to manage access to the interfaces that it provides, but it does not provide
security for this data. If it is run over standard HTTP, the user tokens could
easily be sniffed, so if security is a concern (such as with large
competitions), then you should enable HTTPS in your web serving software (aka,
Apache, Nginx, Lighttpd, or Microsoft IIS).</p>
<p>The interfaces for Cheshire Cat are all written as plugins, defined as modules
within the blueprints folder. Any routes defined within a module in this folder
will beautomatically loaded when Cheshire Cat is started up, making it easy to
add and test new routes. By using this, no new routes have to be defined
anywhere else, and the information about each route is kept with that route.
Check the Cheshire docs if you would like to create new interfaces for Cheshire
Cat.</p>
<p>Due to its simplicity, this is all that can be said about the design of
Cheshire Cat. If you are wanting to use it with your application, I would
suggest checking its docs for all the REST interfaces.</p>
</div>
<div class="section" id="white-rabbit">
<h2>White Rabbit<a class="headerlink" href="#white-rabbit" title="Permalink to this headline">¶</a></h2>
<p>White Rabbit is the work horse behind the scoring engine, in that it manages
all the checks that are being run for each team. It is similar to Cron, the job
scheduler for Unix-like operating systems, and allows for you to schedule
checks to be run in certain intervals or at a specific time. Checks can be one
of four types: Service, Attacker, Inject, and Manual. Each of these types have
different properties and intended uses in scoring a competition.</p>
<p>Service checks are checks that will run for all teams at periodic intervals.
These checks are meant to be used for checking whether certain services remain
up throughout the competition. The scoring engine will add the number of points
returned by the check to the overall score.</p>
<p>Attacker checks are similar to Service checks, but will run for only a certain
team at periodic intervals. The intention is that the attacker, after finding a
security hole for a specific team, will write a test for that security hole,
and then submit that check to the administrator of the scoring engine. The
scoring engine will then run the check and deduct the appropriate number of
points from the user.</p>
<p>Inject checks are checks that are intended to be run at a certain time in order
to judge the successful completion of a business task. This may be as simple as
whether a team removed some infected files from the system or whether they had
set up a new service. These are only scored once, unlike the Service and
Attacker checks.</p>
<p>Manual checks are checks that have to be added manually to the database, and
are not handled explicitly by White Rabbit, but are still useful to mention
here. These checks are intended for items that can not be easily scored in an
automated fashion, such as presentations or reports. These are scored
immediately upon being submitted into the engine, and are available to cover
any types of checks not covered by the other three checks.</p>
</div>
<div class="section" id="uml-diagrams">
<h2>UML Diagrams<a class="headerlink" href="#uml-diagrams" title="Permalink to this headline">¶</a></h2>
<p>I have included these UML diagrams in order to facilitate the understanding of
the designs mentioned above. Included with each diagram is a description
describing each step in the diagram. Hopefully someone will find them helpful
in understanding the engine.</p>
<div class="section" id="engine-architecture">
<h3>Engine Architecture<a class="headerlink" href="#engine-architecture" title="Permalink to this headline">¶</a></h3>
<img alt="../_images/Wonderland-Overall-Design.png" class="align-center" src="../_images/Wonderland-Overall-Design.png" />
<p>This image further emphasizes the three-pronged approach of the Wonderland
Engine, emphasizing the roles that each component takes and the communication
channels for each component. These communication channels are lettered, and
will be explained in the points that follow.</p>
<blockquote>
<div><p><strong>A:</strong> Cheshire Cat pulls most of its information from Doorknob, the
database wrapper. It may do some processing on the data before sending it
back to the client, such as serializing some objects that are not normally
JSON serializable (such as datetimes), but usually the data is as you would
see it if you looked in the database. In addition, it does some data
validation that would not be appropriate for the wrapper to do, such as
checking that a role is in a set of defined roles for users.</p>
<p><strong>B:</strong> Doorknob does most of the heavy lifting by providing a common
interface among databases in order to ease communication between both White
Rabbit and Cheshire Cat and the database itself. One thing to note is that
Doorknob does not have to communicate with MongoDB, as is pictured above. A
wrapper for MongoDB is included by default, but any database with a wrapper
that implements Doorknob&#8217;s DBWrapper abstract class may be used instead. If
you would like to use another database, feel free to write a new wrapper
class and submit a patch!</p>
<p><strong>C:</strong> White Rabbit communicates with the database in order to store a list
of loaded check modules and classes, and to get the list of checks to use
for its checking processes. It also stores the score after running each
check in the database, and recalculates the scores after each change.</p>
<p><strong>D:</strong> If certain portions of the database are changed that affect checking
(such as the list of active checks in the database), Cheshire Cat will
publish a command to a Redis pub sub channel specified in the Engine config
file. This allows for any program listening on that channel to receive and
interpret any sent commands as they wish, regardless of programming
language or implementation.</p>
<p><strong>E:</strong> White Rabbit listens to the Redis pub sub channel specified in the
Engine&#8217;s config file for commands that signal changes it should enact on.
These changes could include the list of checks being changed, or whether
to start or stop checking. If you would like more information on this,
please see the documentation for <a class="reference internal" href="../doorknob/index.html"><em>Doorknob</em></a>.</p>
</div></blockquote>
<p>Unfortunately, due to time constraints, D and E (the communication through
Redis&#8217;s pub sub channels) are hard coded into both Cheshire Cat and White
Rabbit. I would like to abstract this out too, so that you could use other
pub sub providers (such as ZeroMQ) without much hassle. If you would like this,
feel free to file a new issue on the Github tracker and propose a design!</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"><p class="logo"><a href="../index.html">
    <img class="logo" src="../_static/engine-logo.png" alt="Logo"/>
</a></p>

<a href="https://github.com/smartboyathome/Wonderland-Engine/">
    <img style="position: fixed; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub">
</a>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Introduction</a><ul>
<li><a class="reference internal" href="#purpose">Purpose</a></li>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#engine-design">Engine Design</a></li>
<li><a class="reference internal" href="#doorknob">Doorknob</a></li>
<li><a class="reference internal" href="#cheshire-cat">Cheshire Cat</a></li>
<li><a class="reference internal" href="#white-rabbit">White Rabbit</a></li>
<li><a class="reference internal" href="#uml-diagrams">UML Diagrams</a><ul>
<li><a class="reference internal" href="#engine-architecture">Engine Architecture</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../index.html" title="previous chapter">Wonderland Engine 0.9 Documentation</a></li>
      <li>Next: <a href="../doorknob/index.html" title="next chapter">Doorknob</a></li>
  </ul></li>
</ul>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/introduction/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="footer">
    &copy; Copyright 2012, Alexander Abbott.
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  
  </body>
</html>